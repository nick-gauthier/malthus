// Automatically generated by odin 1.2.4 - do not edit
#include <float.h>
#include <R.h>
#include <Rmath.h>
#include <Rinternals.h>
#include <stdbool.h>
#include <R_ext/Rdynload.h>
typedef struct elite_extraction_internal {
  double a;
  double beta1;
  double beta2;
  double delta1;
  double delta2;
  double epsilon;
  double g;
  double initial_E;
  double initial_P;
  double rho0;
} elite_extraction_internal;
typedef struct fiscal_demographic_war_internal {
  double a;
  double alpha;
  double b;
  double beta;
  double c;
  double delta;
  double initial_N;
  double initial_S;
  double initial_W;
  double kmax;
  double r;
  double rho;
} fiscal_demographic_war_internal;
typedef struct fiscal_demographic_internal {
  double beta;
  double c;
  double initial_N;
  double initial_S;
  double k0;
  double r;
  double rho;
  double s0;
} fiscal_demographic_internal;
typedef struct nefedov_internal {
  double food;
  double initial_K;
  double initial_N;
  double q;
  double r;
} nefedov_internal;
typedef struct scaling_cities_internal {
  double alpha;
  double beta;
  double E;
  double H;
  double Im;
  double initial_N;
  double initial_Y;
  double K;
  double M;
  double r;
  double Tr;
} scaling_cities_internal;
typedef struct stateless_war_internal {
  double a;
  double b;
  double c;
  double initial_N;
  double initial_W;
  double K;
  double kmax;
  double r;
} stateless_war_internal;
elite_extraction_internal* elite_extraction_get_internal(SEXP internal_p, int closed_error);
static void elite_extraction_finalise(SEXP internal_p);
SEXP elite_extraction_create(SEXP user);
void elite_extraction_initmod_desolve(void(* odeparms) (int *, double *));
SEXP elite_extraction_contents(SEXP internal_p);
SEXP elite_extraction_set_user(SEXP internal_p, SEXP user);
SEXP elite_extraction_set_initial(SEXP internal_p, SEXP t_ptr, SEXP state_ptr, SEXP elite_extraction_use_dde_ptr);
SEXP elite_extraction_metadata(SEXP internal_p);
SEXP elite_extraction_initial_conditions(SEXP internal_p, SEXP t_ptr);
void elite_extraction_rhs(elite_extraction_internal* internal, double t, double * state, double * dstatedt, double * output);
void elite_extraction_rhs_dde(size_t neq, double t, double * state, double * dstatedt, void * internal);
void elite_extraction_rhs_desolve(int * neq, double * t, double * state, double * dstatedt, double * output, int * np);
SEXP elite_extraction_rhs_r(SEXP internal_p, SEXP t, SEXP state);
fiscal_demographic_war_internal* fiscal_demographic_war_get_internal(SEXP internal_p, int closed_error);
static void fiscal_demographic_war_finalise(SEXP internal_p);
SEXP fiscal_demographic_war_create(SEXP user);
void fiscal_demographic_war_initmod_desolve(void(* odeparms) (int *, double *));
SEXP fiscal_demographic_war_contents(SEXP internal_p);
SEXP fiscal_demographic_war_set_user(SEXP internal_p, SEXP user);
SEXP fiscal_demographic_war_set_initial(SEXP internal_p, SEXP t_ptr, SEXP state_ptr, SEXP fiscal_demographic_war_use_dde_ptr);
SEXP fiscal_demographic_war_metadata(SEXP internal_p);
SEXP fiscal_demographic_war_initial_conditions(SEXP internal_p, SEXP t_ptr);
void fiscal_demographic_war_rhs(fiscal_demographic_war_internal* internal, double t, double * state, double * dstatedt, double * output);
void fiscal_demographic_war_rhs_dde(size_t neq, double t, double * state, double * dstatedt, void * internal);
void fiscal_demographic_war_rhs_desolve(int * neq, double * t, double * state, double * dstatedt, double * output, int * np);
SEXP fiscal_demographic_war_rhs_r(SEXP internal_p, SEXP t, SEXP state);
fiscal_demographic_internal* fiscal_demographic_get_internal(SEXP internal_p, int closed_error);
static void fiscal_demographic_finalise(SEXP internal_p);
SEXP fiscal_demographic_create(SEXP user);
void fiscal_demographic_initmod_desolve(void(* odeparms) (int *, double *));
SEXP fiscal_demographic_contents(SEXP internal_p);
SEXP fiscal_demographic_set_user(SEXP internal_p, SEXP user);
SEXP fiscal_demographic_set_initial(SEXP internal_p, SEXP t_ptr, SEXP state_ptr, SEXP fiscal_demographic_use_dde_ptr);
SEXP fiscal_demographic_metadata(SEXP internal_p);
SEXP fiscal_demographic_initial_conditions(SEXP internal_p, SEXP t_ptr);
void fiscal_demographic_rhs(fiscal_demographic_internal* internal, double t, double * state, double * dstatedt, double * output);
void fiscal_demographic_rhs_dde(size_t neq, double t, double * state, double * dstatedt, void * internal);
void fiscal_demographic_rhs_desolve(int * neq, double * t, double * state, double * dstatedt, double * output, int * np);
SEXP fiscal_demographic_rhs_r(SEXP internal_p, SEXP t, SEXP state);
nefedov_internal* nefedov_get_internal(SEXP internal_p, int closed_error);
static void nefedov_finalise(SEXP internal_p);
SEXP nefedov_create(SEXP user);
void nefedov_initmod_desolve(void(* odeparms) (int *, double *));
SEXP nefedov_contents(SEXP internal_p);
SEXP nefedov_set_user(SEXP internal_p, SEXP user);
SEXP nefedov_set_initial(SEXP internal_p, SEXP t_ptr, SEXP state_ptr, SEXP nefedov_use_dde_ptr);
SEXP nefedov_metadata(SEXP internal_p);
SEXP nefedov_initial_conditions(SEXP internal_p, SEXP t_ptr);
void nefedov_rhs(nefedov_internal* internal, double t, double * state, double * dstatedt, double * output);
void nefedov_rhs_dde(size_t neq, double t, double * state, double * dstatedt, void * internal);
void nefedov_rhs_desolve(int * neq, double * t, double * state, double * dstatedt, double * output, int * np);
SEXP nefedov_rhs_r(SEXP internal_p, SEXP t, SEXP state);
scaling_cities_internal* scaling_cities_get_internal(SEXP internal_p, int closed_error);
static void scaling_cities_finalise(SEXP internal_p);
SEXP scaling_cities_create(SEXP user);
void scaling_cities_initmod_desolve(void(* odeparms) (int *, double *));
SEXP scaling_cities_contents(SEXP internal_p);
SEXP scaling_cities_set_user(SEXP internal_p, SEXP user);
SEXP scaling_cities_set_initial(SEXP internal_p, SEXP t_ptr, SEXP state_ptr, SEXP scaling_cities_use_dde_ptr);
SEXP scaling_cities_metadata(SEXP internal_p);
SEXP scaling_cities_initial_conditions(SEXP internal_p, SEXP t_ptr);
void scaling_cities_rhs(scaling_cities_internal* internal, double t, double * state, double * dstatedt, double * output);
void scaling_cities_rhs_dde(size_t neq, double t, double * state, double * dstatedt, void * internal);
void scaling_cities_rhs_desolve(int * neq, double * t, double * state, double * dstatedt, double * output, int * np);
SEXP scaling_cities_rhs_r(SEXP internal_p, SEXP t, SEXP state);
stateless_war_internal* stateless_war_get_internal(SEXP internal_p, int closed_error);
static void stateless_war_finalise(SEXP internal_p);
SEXP stateless_war_create(SEXP user);
void stateless_war_initmod_desolve(void(* odeparms) (int *, double *));
SEXP stateless_war_contents(SEXP internal_p);
SEXP stateless_war_set_user(SEXP internal_p, SEXP user);
SEXP stateless_war_set_initial(SEXP internal_p, SEXP t_ptr, SEXP state_ptr, SEXP stateless_war_use_dde_ptr);
SEXP stateless_war_metadata(SEXP internal_p);
SEXP stateless_war_initial_conditions(SEXP internal_p, SEXP t_ptr);
void stateless_war_rhs(stateless_war_internal* internal, double t, double * state, double * dstatedt, double * output);
void stateless_war_rhs_dde(size_t neq, double t, double * state, double * dstatedt, void * internal);
void stateless_war_rhs_desolve(int * neq, double * t, double * state, double * dstatedt, double * output, int * np);
SEXP stateless_war_rhs_r(SEXP internal_p, SEXP t, SEXP state);
double user_get_scalar_double(SEXP user, const char *name,
                              double default_value, double min, double max);
int user_get_scalar_int(SEXP user, const char *name,
                        int default_value, double min, double max);
void user_check_values_double(double * value, size_t len,
                                  double min, double max, const char *name);
void user_check_values_int(int * value, size_t len,
                               double min, double max, const char *name);
void user_check_values(SEXP value, double min, double max,
                           const char *name);
SEXP user_list_element(SEXP list, const char *name);
double scalar_real(SEXP x, const char * name);
elite_extraction_internal* elite_extraction_get_internal(SEXP internal_p, int closed_error) {
  elite_extraction_internal *internal = NULL;
  if (TYPEOF(internal_p) != EXTPTRSXP) {
    Rf_error("Expected an external pointer");
  }
  internal = (elite_extraction_internal*) R_ExternalPtrAddr(internal_p);
  if (!internal && closed_error) {
    Rf_error("Pointer has been invalidated");
  }
  return internal;
}
void elite_extraction_finalise(SEXP internal_p) {
  elite_extraction_internal *internal = elite_extraction_get_internal(internal_p, 0);
  if (internal_p) {
    R_Free(internal);
    R_ClearExternalPtr(internal_p);
  }
}
SEXP elite_extraction_create(SEXP user) {
  elite_extraction_internal *internal = (elite_extraction_internal*) R_Calloc(1, elite_extraction_internal);
  internal->initial_E = 10;
  internal->initial_P = 100;
  internal->a = 0.10000000000000001;
  internal->beta1 = 0.02;
  internal->beta2 = 0.5;
  internal->delta1 = 0.02;
  internal->delta2 = 0.025000000000000001;
  internal->epsilon = 0.10000000000000001;
  internal->g = 0.0001;
  internal->rho0 = 2;
  SEXP ptr = PROTECT(R_MakeExternalPtr(internal, R_NilValue, R_NilValue));
  R_RegisterCFinalizer(ptr, elite_extraction_finalise);
  UNPROTECT(1);
  return ptr;
}
static elite_extraction_internal *elite_extraction_internal_ds;
void elite_extraction_initmod_desolve(void(* odeparms) (int *, double *)) {
  static DL_FUNC get_desolve_gparms = NULL;
  if (get_desolve_gparms == NULL) {
    get_desolve_gparms =
      R_GetCCallable("deSolve", "get_deSolve_gparms");
  }
  elite_extraction_internal_ds = elite_extraction_get_internal(get_desolve_gparms(), 1);
}
SEXP elite_extraction_contents(SEXP internal_p) {
  elite_extraction_internal *internal = elite_extraction_get_internal(internal_p, 1);
  SEXP contents = PROTECT(allocVector(VECSXP, 10));
  SET_VECTOR_ELT(contents, 0, ScalarReal(internal->a));
  SET_VECTOR_ELT(contents, 1, ScalarReal(internal->beta1));
  SET_VECTOR_ELT(contents, 2, ScalarReal(internal->beta2));
  SET_VECTOR_ELT(contents, 3, ScalarReal(internal->delta1));
  SET_VECTOR_ELT(contents, 4, ScalarReal(internal->delta2));
  SET_VECTOR_ELT(contents, 5, ScalarReal(internal->epsilon));
  SET_VECTOR_ELT(contents, 6, ScalarReal(internal->g));
  SET_VECTOR_ELT(contents, 7, ScalarReal(internal->initial_E));
  SET_VECTOR_ELT(contents, 8, ScalarReal(internal->initial_P));
  SET_VECTOR_ELT(contents, 9, ScalarReal(internal->rho0));
  SEXP nms = PROTECT(allocVector(STRSXP, 10));
  SET_STRING_ELT(nms, 0, mkChar("a"));
  SET_STRING_ELT(nms, 1, mkChar("beta1"));
  SET_STRING_ELT(nms, 2, mkChar("beta2"));
  SET_STRING_ELT(nms, 3, mkChar("delta1"));
  SET_STRING_ELT(nms, 4, mkChar("delta2"));
  SET_STRING_ELT(nms, 5, mkChar("epsilon"));
  SET_STRING_ELT(nms, 6, mkChar("g"));
  SET_STRING_ELT(nms, 7, mkChar("initial_E"));
  SET_STRING_ELT(nms, 8, mkChar("initial_P"));
  SET_STRING_ELT(nms, 9, mkChar("rho0"));
  setAttrib(contents, R_NamesSymbol, nms);
  UNPROTECT(2);
  return contents;
}
SEXP elite_extraction_set_user(SEXP internal_p, SEXP user) {
  elite_extraction_internal *internal = elite_extraction_get_internal(internal_p, 1);
  internal->a = user_get_scalar_double(user, "a", internal->a, NA_REAL, NA_REAL);
  internal->beta1 = user_get_scalar_double(user, "beta1", internal->beta1, NA_REAL, NA_REAL);
  internal->beta2 = user_get_scalar_double(user, "beta2", internal->beta2, NA_REAL, NA_REAL);
  internal->delta1 = user_get_scalar_double(user, "delta1", internal->delta1, NA_REAL, NA_REAL);
  internal->delta2 = user_get_scalar_double(user, "delta2", internal->delta2, NA_REAL, NA_REAL);
  internal->epsilon = user_get_scalar_double(user, "epsilon", internal->epsilon, NA_REAL, NA_REAL);
  internal->g = user_get_scalar_double(user, "g", internal->g, NA_REAL, NA_REAL);
  internal->rho0 = user_get_scalar_double(user, "rho0", internal->rho0, NA_REAL, NA_REAL);
  return R_NilValue;
}
SEXP elite_extraction_set_initial(SEXP internal_p, SEXP t_ptr, SEXP state_ptr, SEXP elite_extraction_use_dde_ptr) {
  return R_NilValue;
}
SEXP elite_extraction_metadata(SEXP internal_p) {
  elite_extraction_internal *internal = elite_extraction_get_internal(internal_p, 1);
  SEXP ret = PROTECT(allocVector(VECSXP, 4));
  SEXP nms = PROTECT(allocVector(STRSXP, 4));
  SET_STRING_ELT(nms, 0, mkChar("variable_order"));
  SET_STRING_ELT(nms, 1, mkChar("output_order"));
  SET_STRING_ELT(nms, 2, mkChar("n_out"));
  SET_STRING_ELT(nms, 3, mkChar("interpolate_t"));
  setAttrib(ret, R_NamesSymbol, nms);
  SEXP variable_length = PROTECT(allocVector(VECSXP, 2));
  SEXP variable_names = PROTECT(allocVector(STRSXP, 2));
  setAttrib(variable_length, R_NamesSymbol, variable_names);
  SET_VECTOR_ELT(variable_length, 0, R_NilValue);
  SET_VECTOR_ELT(variable_length, 1, R_NilValue);
  SET_STRING_ELT(variable_names, 0, mkChar("P"));
  SET_STRING_ELT(variable_names, 1, mkChar("E"));
  SET_VECTOR_ELT(ret, 0, variable_length);
  UNPROTECT(2);
  SET_VECTOR_ELT(ret, 1, R_NilValue);
  SET_VECTOR_ELT(ret, 2, ScalarInteger(0));
  UNPROTECT(2);
  return ret;
}
SEXP elite_extraction_initial_conditions(SEXP internal_p, SEXP t_ptr) {
  elite_extraction_internal *internal = elite_extraction_get_internal(internal_p, 1);
  SEXP r_state = PROTECT(allocVector(REALSXP, 2));
  double * state = REAL(r_state);
  state[0] = internal->initial_P;
  state[1] = internal->initial_E;
  UNPROTECT(1);
  return r_state;
}
void elite_extraction_rhs(elite_extraction_internal* internal, double t, double * state, double * dstatedt, double * output) {
  double P = state[0];
  double E = state[1];
  double rho_e = internal->rho0 * internal->epsilon * internal->a * (1 - internal->g * P) * P / (double) (1 + internal->a * E);
  double rho_p = internal->rho0 * (1 + (1 - internal->epsilon) * internal->a * E) * (1 - internal->g * P) / (double) (1 + internal->a * E);
  dstatedt[1] = (internal->beta2 * rho_e - internal->delta2) * E;
  dstatedt[0] = (internal->beta1 * rho_p - internal->delta1) * P;
}
void elite_extraction_rhs_dde(size_t neq, double t, double * state, double * dstatedt, void * internal) {
  elite_extraction_rhs((elite_extraction_internal*)internal, t, state, dstatedt, NULL);
}
void elite_extraction_rhs_desolve(int * neq, double * t, double * state, double * dstatedt, double * output, int * np) {
  elite_extraction_rhs(elite_extraction_internal_ds, *t, state, dstatedt, output);
}
SEXP elite_extraction_rhs_r(SEXP internal_p, SEXP t, SEXP state) {
  SEXP dstatedt = PROTECT(allocVector(REALSXP, LENGTH(state)));
  elite_extraction_internal *internal = elite_extraction_get_internal(internal_p, 1);
  double *output = NULL;
  elite_extraction_rhs(internal, scalar_real(t, "t"), REAL(state), REAL(dstatedt), output);
  UNPROTECT(1);
  return dstatedt;
}
fiscal_demographic_war_internal* fiscal_demographic_war_get_internal(SEXP internal_p, int closed_error) {
  fiscal_demographic_war_internal *internal = NULL;
  if (TYPEOF(internal_p) != EXTPTRSXP) {
    Rf_error("Expected an external pointer");
  }
  internal = (fiscal_demographic_war_internal*) R_ExternalPtrAddr(internal_p);
  if (!internal && closed_error) {
    Rf_error("Pointer has been invalidated");
  }
  return internal;
}
void fiscal_demographic_war_finalise(SEXP internal_p) {
  fiscal_demographic_war_internal *internal = fiscal_demographic_war_get_internal(internal_p, 0);
  if (internal_p) {
    R_Free(internal);
    R_ClearExternalPtr(internal_p);
  }
}
SEXP fiscal_demographic_war_create(SEXP user) {
  fiscal_demographic_war_internal *internal = (fiscal_demographic_war_internal*) R_Calloc(1, fiscal_demographic_war_internal);
  internal->initial_N = 0.5;
  internal->initial_S = 0;
  internal->initial_W = 0.5;
  internal->a = 0.01;
  internal->alpha = 0.10000000000000001;
  internal->b = 0.050000000000000003;
  internal->beta = 0.25;
  internal->c = 1;
  internal->delta = 0.10000000000000001;
  internal->kmax = 3;
  internal->r = 0.014999999999999999;
  internal->rho = 1;
  SEXP ptr = PROTECT(R_MakeExternalPtr(internal, R_NilValue, R_NilValue));
  R_RegisterCFinalizer(ptr, fiscal_demographic_war_finalise);
  UNPROTECT(1);
  return ptr;
}
static fiscal_demographic_war_internal *fiscal_demographic_war_internal_ds;
void fiscal_demographic_war_initmod_desolve(void(* odeparms) (int *, double *)) {
  static DL_FUNC get_desolve_gparms = NULL;
  if (get_desolve_gparms == NULL) {
    get_desolve_gparms =
      R_GetCCallable("deSolve", "get_deSolve_gparms");
  }
  fiscal_demographic_war_internal_ds = fiscal_demographic_war_get_internal(get_desolve_gparms(), 1);
}
SEXP fiscal_demographic_war_contents(SEXP internal_p) {
  fiscal_demographic_war_internal *internal = fiscal_demographic_war_get_internal(internal_p, 1);
  SEXP contents = PROTECT(allocVector(VECSXP, 12));
  SET_VECTOR_ELT(contents, 0, ScalarReal(internal->a));
  SET_VECTOR_ELT(contents, 1, ScalarReal(internal->alpha));
  SET_VECTOR_ELT(contents, 2, ScalarReal(internal->b));
  SET_VECTOR_ELT(contents, 3, ScalarReal(internal->beta));
  SET_VECTOR_ELT(contents, 4, ScalarReal(internal->c));
  SET_VECTOR_ELT(contents, 5, ScalarReal(internal->delta));
  SET_VECTOR_ELT(contents, 6, ScalarReal(internal->initial_N));
  SET_VECTOR_ELT(contents, 7, ScalarReal(internal->initial_S));
  SET_VECTOR_ELT(contents, 8, ScalarReal(internal->initial_W));
  SET_VECTOR_ELT(contents, 9, ScalarReal(internal->kmax));
  SET_VECTOR_ELT(contents, 10, ScalarReal(internal->r));
  SET_VECTOR_ELT(contents, 11, ScalarReal(internal->rho));
  SEXP nms = PROTECT(allocVector(STRSXP, 12));
  SET_STRING_ELT(nms, 0, mkChar("a"));
  SET_STRING_ELT(nms, 1, mkChar("alpha"));
  SET_STRING_ELT(nms, 2, mkChar("b"));
  SET_STRING_ELT(nms, 3, mkChar("beta"));
  SET_STRING_ELT(nms, 4, mkChar("c"));
  SET_STRING_ELT(nms, 5, mkChar("delta"));
  SET_STRING_ELT(nms, 6, mkChar("initial_N"));
  SET_STRING_ELT(nms, 7, mkChar("initial_S"));
  SET_STRING_ELT(nms, 8, mkChar("initial_W"));
  SET_STRING_ELT(nms, 9, mkChar("kmax"));
  SET_STRING_ELT(nms, 10, mkChar("r"));
  SET_STRING_ELT(nms, 11, mkChar("rho"));
  setAttrib(contents, R_NamesSymbol, nms);
  UNPROTECT(2);
  return contents;
}
SEXP fiscal_demographic_war_set_user(SEXP internal_p, SEXP user) {
  fiscal_demographic_war_internal *internal = fiscal_demographic_war_get_internal(internal_p, 1);
  internal->a = user_get_scalar_double(user, "a", internal->a, NA_REAL, NA_REAL);
  internal->alpha = user_get_scalar_double(user, "alpha", internal->alpha, NA_REAL, NA_REAL);
  internal->b = user_get_scalar_double(user, "b", internal->b, NA_REAL, NA_REAL);
  internal->beta = user_get_scalar_double(user, "beta", internal->beta, NA_REAL, NA_REAL);
  internal->c = user_get_scalar_double(user, "c", internal->c, NA_REAL, NA_REAL);
  internal->delta = user_get_scalar_double(user, "delta", internal->delta, NA_REAL, NA_REAL);
  internal->kmax = user_get_scalar_double(user, "kmax", internal->kmax, NA_REAL, NA_REAL);
  internal->r = user_get_scalar_double(user, "r", internal->r, NA_REAL, NA_REAL);
  internal->rho = user_get_scalar_double(user, "rho", internal->rho, NA_REAL, NA_REAL);
  return R_NilValue;
}
SEXP fiscal_demographic_war_set_initial(SEXP internal_p, SEXP t_ptr, SEXP state_ptr, SEXP fiscal_demographic_war_use_dde_ptr) {
  return R_NilValue;
}
SEXP fiscal_demographic_war_metadata(SEXP internal_p) {
  fiscal_demographic_war_internal *internal = fiscal_demographic_war_get_internal(internal_p, 1);
  SEXP ret = PROTECT(allocVector(VECSXP, 4));
  SEXP nms = PROTECT(allocVector(STRSXP, 4));
  SET_STRING_ELT(nms, 0, mkChar("variable_order"));
  SET_STRING_ELT(nms, 1, mkChar("output_order"));
  SET_STRING_ELT(nms, 2, mkChar("n_out"));
  SET_STRING_ELT(nms, 3, mkChar("interpolate_t"));
  setAttrib(ret, R_NamesSymbol, nms);
  SEXP variable_length = PROTECT(allocVector(VECSXP, 3));
  SEXP variable_names = PROTECT(allocVector(STRSXP, 3));
  setAttrib(variable_length, R_NamesSymbol, variable_names);
  SET_VECTOR_ELT(variable_length, 0, R_NilValue);
  SET_VECTOR_ELT(variable_length, 1, R_NilValue);
  SET_VECTOR_ELT(variable_length, 2, R_NilValue);
  SET_STRING_ELT(variable_names, 0, mkChar("N"));
  SET_STRING_ELT(variable_names, 1, mkChar("S"));
  SET_STRING_ELT(variable_names, 2, mkChar("W"));
  SET_VECTOR_ELT(ret, 0, variable_length);
  UNPROTECT(2);
  SET_VECTOR_ELT(ret, 1, R_NilValue);
  SET_VECTOR_ELT(ret, 2, ScalarInteger(0));
  UNPROTECT(2);
  return ret;
}
SEXP fiscal_demographic_war_initial_conditions(SEXP internal_p, SEXP t_ptr) {
  fiscal_demographic_war_internal *internal = fiscal_demographic_war_get_internal(internal_p, 1);
  SEXP r_state = PROTECT(allocVector(REALSXP, 3));
  double * state = REAL(r_state);
  state[0] = internal->initial_N;
  state[1] = internal->initial_S;
  state[2] = internal->initial_W;
  UNPROTECT(1);
  return r_state;
}
void fiscal_demographic_war_rhs(fiscal_demographic_war_internal* internal, double t, double * state, double * dstatedt, double * output) {
  double N = state[0];
  double S = state[1];
  double W = state[2];
  dstatedt[2] = internal->a * pow(N, 2) - internal->b * W - internal->alpha * S;
  double K = internal->kmax - internal->c * W;
  dstatedt[0] = internal->r * N * (1 - N / (double) K) - internal->delta * N * W;
  dstatedt[1] = internal->rho * N * (1 - N / (double) K) - internal->beta * N;
}
void fiscal_demographic_war_rhs_dde(size_t neq, double t, double * state, double * dstatedt, void * internal) {
  fiscal_demographic_war_rhs((fiscal_demographic_war_internal*)internal, t, state, dstatedt, NULL);
}
void fiscal_demographic_war_rhs_desolve(int * neq, double * t, double * state, double * dstatedt, double * output, int * np) {
  fiscal_demographic_war_rhs(fiscal_demographic_war_internal_ds, *t, state, dstatedt, output);
}
SEXP fiscal_demographic_war_rhs_r(SEXP internal_p, SEXP t, SEXP state) {
  SEXP dstatedt = PROTECT(allocVector(REALSXP, LENGTH(state)));
  fiscal_demographic_war_internal *internal = fiscal_demographic_war_get_internal(internal_p, 1);
  double *output = NULL;
  fiscal_demographic_war_rhs(internal, scalar_real(t, "t"), REAL(state), REAL(dstatedt), output);
  UNPROTECT(1);
  return dstatedt;
}
fiscal_demographic_internal* fiscal_demographic_get_internal(SEXP internal_p, int closed_error) {
  fiscal_demographic_internal *internal = NULL;
  if (TYPEOF(internal_p) != EXTPTRSXP) {
    Rf_error("Expected an external pointer");
  }
  internal = (fiscal_demographic_internal*) R_ExternalPtrAddr(internal_p);
  if (!internal && closed_error) {
    Rf_error("Pointer has been invalidated");
  }
  return internal;
}
void fiscal_demographic_finalise(SEXP internal_p) {
  fiscal_demographic_internal *internal = fiscal_demographic_get_internal(internal_p, 0);
  if (internal_p) {
    R_Free(internal);
    R_ClearExternalPtr(internal_p);
  }
}
SEXP fiscal_demographic_create(SEXP user) {
  fiscal_demographic_internal *internal = (fiscal_demographic_internal*) R_Calloc(1, fiscal_demographic_internal);
  internal->initial_N = 50;
  internal->initial_S = 200;
  internal->beta = 1;
  internal->c = 400;
  internal->k0 = 100;
  internal->r = 0.02;
  internal->rho = 0.20000000000000001;
  internal->s0 = 300;
  SEXP ptr = PROTECT(R_MakeExternalPtr(internal, R_NilValue, R_NilValue));
  R_RegisterCFinalizer(ptr, fiscal_demographic_finalise);
  UNPROTECT(1);
  return ptr;
}
static fiscal_demographic_internal *fiscal_demographic_internal_ds;
void fiscal_demographic_initmod_desolve(void(* odeparms) (int *, double *)) {
  static DL_FUNC get_desolve_gparms = NULL;
  if (get_desolve_gparms == NULL) {
    get_desolve_gparms =
      R_GetCCallable("deSolve", "get_deSolve_gparms");
  }
  fiscal_demographic_internal_ds = fiscal_demographic_get_internal(get_desolve_gparms(), 1);
}
SEXP fiscal_demographic_contents(SEXP internal_p) {
  fiscal_demographic_internal *internal = fiscal_demographic_get_internal(internal_p, 1);
  SEXP contents = PROTECT(allocVector(VECSXP, 8));
  SET_VECTOR_ELT(contents, 0, ScalarReal(internal->beta));
  SET_VECTOR_ELT(contents, 1, ScalarReal(internal->c));
  SET_VECTOR_ELT(contents, 2, ScalarReal(internal->initial_N));
  SET_VECTOR_ELT(contents, 3, ScalarReal(internal->initial_S));
  SET_VECTOR_ELT(contents, 4, ScalarReal(internal->k0));
  SET_VECTOR_ELT(contents, 5, ScalarReal(internal->r));
  SET_VECTOR_ELT(contents, 6, ScalarReal(internal->rho));
  SET_VECTOR_ELT(contents, 7, ScalarReal(internal->s0));
  SEXP nms = PROTECT(allocVector(STRSXP, 8));
  SET_STRING_ELT(nms, 0, mkChar("beta"));
  SET_STRING_ELT(nms, 1, mkChar("c"));
  SET_STRING_ELT(nms, 2, mkChar("initial_N"));
  SET_STRING_ELT(nms, 3, mkChar("initial_S"));
  SET_STRING_ELT(nms, 4, mkChar("k0"));
  SET_STRING_ELT(nms, 5, mkChar("r"));
  SET_STRING_ELT(nms, 6, mkChar("rho"));
  SET_STRING_ELT(nms, 7, mkChar("s0"));
  setAttrib(contents, R_NamesSymbol, nms);
  UNPROTECT(2);
  return contents;
}
SEXP fiscal_demographic_set_user(SEXP internal_p, SEXP user) {
  fiscal_demographic_internal *internal = fiscal_demographic_get_internal(internal_p, 1);
  internal->beta = user_get_scalar_double(user, "beta", internal->beta, NA_REAL, NA_REAL);
  internal->c = user_get_scalar_double(user, "c", internal->c, NA_REAL, NA_REAL);
  internal->k0 = user_get_scalar_double(user, "k0", internal->k0, NA_REAL, NA_REAL);
  internal->r = user_get_scalar_double(user, "r", internal->r, NA_REAL, NA_REAL);
  internal->rho = user_get_scalar_double(user, "rho", internal->rho, NA_REAL, NA_REAL);
  internal->s0 = user_get_scalar_double(user, "s0", internal->s0, NA_REAL, NA_REAL);
  return R_NilValue;
}
SEXP fiscal_demographic_set_initial(SEXP internal_p, SEXP t_ptr, SEXP state_ptr, SEXP fiscal_demographic_use_dde_ptr) {
  return R_NilValue;
}
SEXP fiscal_demographic_metadata(SEXP internal_p) {
  fiscal_demographic_internal *internal = fiscal_demographic_get_internal(internal_p, 1);
  SEXP ret = PROTECT(allocVector(VECSXP, 4));
  SEXP nms = PROTECT(allocVector(STRSXP, 4));
  SET_STRING_ELT(nms, 0, mkChar("variable_order"));
  SET_STRING_ELT(nms, 1, mkChar("output_order"));
  SET_STRING_ELT(nms, 2, mkChar("n_out"));
  SET_STRING_ELT(nms, 3, mkChar("interpolate_t"));
  setAttrib(ret, R_NamesSymbol, nms);
  SEXP variable_length = PROTECT(allocVector(VECSXP, 2));
  SEXP variable_names = PROTECT(allocVector(STRSXP, 2));
  setAttrib(variable_length, R_NamesSymbol, variable_names);
  SET_VECTOR_ELT(variable_length, 0, R_NilValue);
  SET_VECTOR_ELT(variable_length, 1, R_NilValue);
  SET_STRING_ELT(variable_names, 0, mkChar("N"));
  SET_STRING_ELT(variable_names, 1, mkChar("S"));
  SET_VECTOR_ELT(ret, 0, variable_length);
  UNPROTECT(2);
  SET_VECTOR_ELT(ret, 1, R_NilValue);
  SET_VECTOR_ELT(ret, 2, ScalarInteger(0));
  UNPROTECT(2);
  return ret;
}
SEXP fiscal_demographic_initial_conditions(SEXP internal_p, SEXP t_ptr) {
  fiscal_demographic_internal *internal = fiscal_demographic_get_internal(internal_p, 1);
  SEXP r_state = PROTECT(allocVector(REALSXP, 2));
  double * state = REAL(r_state);
  state[0] = internal->initial_N;
  state[1] = internal->initial_S;
  UNPROTECT(1);
  return r_state;
}
void fiscal_demographic_rhs(fiscal_demographic_internal* internal, double t, double * state, double * dstatedt, double * output) {
  double N = state[0];
  double S = state[1];
  double K = internal->k0 * (1 + internal->c * S / (double) (internal->s0 + S));
  dstatedt[0] = internal->r * N * (1 - N / (double) K);
  double s_deriv = internal->rho * N * (1 - N / (double) K) - internal->beta * N;
  dstatedt[1] = ((S + s_deriv) < 0 ? -(S) : s_deriv);
}
void fiscal_demographic_rhs_dde(size_t neq, double t, double * state, double * dstatedt, void * internal) {
  fiscal_demographic_rhs((fiscal_demographic_internal*)internal, t, state, dstatedt, NULL);
}
void fiscal_demographic_rhs_desolve(int * neq, double * t, double * state, double * dstatedt, double * output, int * np) {
  fiscal_demographic_rhs(fiscal_demographic_internal_ds, *t, state, dstatedt, output);
}
SEXP fiscal_demographic_rhs_r(SEXP internal_p, SEXP t, SEXP state) {
  SEXP dstatedt = PROTECT(allocVector(REALSXP, LENGTH(state)));
  fiscal_demographic_internal *internal = fiscal_demographic_get_internal(internal_p, 1);
  double *output = NULL;
  fiscal_demographic_rhs(internal, scalar_real(t, "t"), REAL(state), REAL(dstatedt), output);
  UNPROTECT(1);
  return dstatedt;
}
nefedov_internal* nefedov_get_internal(SEXP internal_p, int closed_error) {
  nefedov_internal *internal = NULL;
  if (TYPEOF(internal_p) != EXTPTRSXP) {
    Rf_error("Expected an external pointer");
  }
  internal = (nefedov_internal*) R_ExternalPtrAddr(internal_p);
  if (!internal && closed_error) {
    Rf_error("Pointer has been invalidated");
  }
  return internal;
}
void nefedov_finalise(SEXP internal_p) {
  nefedov_internal *internal = nefedov_get_internal(internal_p, 0);
  if (internal_p) {
    R_Free(internal);
    R_ClearExternalPtr(internal_p);
  }
}
SEXP nefedov_create(SEXP user) {
  nefedov_internal *internal = (nefedov_internal*) R_Calloc(1, nefedov_internal);
  internal->initial_K = 100;
  internal->initial_N = 50;
  internal->food = 100;
  internal->q = 1.2;
  internal->r = 0.02;
  SEXP ptr = PROTECT(R_MakeExternalPtr(internal, R_NilValue, R_NilValue));
  R_RegisterCFinalizer(ptr, nefedov_finalise);
  UNPROTECT(1);
  return ptr;
}
static nefedov_internal *nefedov_internal_ds;
void nefedov_initmod_desolve(void(* odeparms) (int *, double *)) {
  static DL_FUNC get_desolve_gparms = NULL;
  if (get_desolve_gparms == NULL) {
    get_desolve_gparms =
      R_GetCCallable("deSolve", "get_deSolve_gparms");
  }
  nefedov_internal_ds = nefedov_get_internal(get_desolve_gparms(), 1);
}
SEXP nefedov_contents(SEXP internal_p) {
  nefedov_internal *internal = nefedov_get_internal(internal_p, 1);
  SEXP contents = PROTECT(allocVector(VECSXP, 5));
  SET_VECTOR_ELT(contents, 0, ScalarReal(internal->food));
  SET_VECTOR_ELT(contents, 1, ScalarReal(internal->initial_K));
  SET_VECTOR_ELT(contents, 2, ScalarReal(internal->initial_N));
  SET_VECTOR_ELT(contents, 3, ScalarReal(internal->q));
  SET_VECTOR_ELT(contents, 4, ScalarReal(internal->r));
  SEXP nms = PROTECT(allocVector(STRSXP, 5));
  SET_STRING_ELT(nms, 0, mkChar("food"));
  SET_STRING_ELT(nms, 1, mkChar("initial_K"));
  SET_STRING_ELT(nms, 2, mkChar("initial_N"));
  SET_STRING_ELT(nms, 3, mkChar("q"));
  SET_STRING_ELT(nms, 4, mkChar("r"));
  setAttrib(contents, R_NamesSymbol, nms);
  UNPROTECT(2);
  return contents;
}
SEXP nefedov_set_user(SEXP internal_p, SEXP user) {
  nefedov_internal *internal = nefedov_get_internal(internal_p, 1);
  internal->food = user_get_scalar_double(user, "food", internal->food, NA_REAL, NA_REAL);
  internal->q = user_get_scalar_double(user, "q", internal->q, NA_REAL, NA_REAL);
  internal->r = user_get_scalar_double(user, "r", internal->r, NA_REAL, NA_REAL);
  return R_NilValue;
}
SEXP nefedov_set_initial(SEXP internal_p, SEXP t_ptr, SEXP state_ptr, SEXP nefedov_use_dde_ptr) {
  return R_NilValue;
}
SEXP nefedov_metadata(SEXP internal_p) {
  nefedov_internal *internal = nefedov_get_internal(internal_p, 1);
  SEXP ret = PROTECT(allocVector(VECSXP, 4));
  SEXP nms = PROTECT(allocVector(STRSXP, 4));
  SET_STRING_ELT(nms, 0, mkChar("variable_order"));
  SET_STRING_ELT(nms, 1, mkChar("output_order"));
  SET_STRING_ELT(nms, 2, mkChar("n_out"));
  SET_STRING_ELT(nms, 3, mkChar("interpolate_t"));
  setAttrib(ret, R_NamesSymbol, nms);
  SEXP variable_length = PROTECT(allocVector(VECSXP, 2));
  SEXP variable_names = PROTECT(allocVector(STRSXP, 2));
  setAttrib(variable_length, R_NamesSymbol, variable_names);
  SET_VECTOR_ELT(variable_length, 0, R_NilValue);
  SET_VECTOR_ELT(variable_length, 1, R_NilValue);
  SET_STRING_ELT(variable_names, 0, mkChar("N"));
  SET_STRING_ELT(variable_names, 1, mkChar("K"));
  SET_VECTOR_ELT(ret, 0, variable_length);
  UNPROTECT(2);
  SET_VECTOR_ELT(ret, 1, R_NilValue);
  SET_VECTOR_ELT(ret, 2, ScalarInteger(0));
  UNPROTECT(2);
  return ret;
}
SEXP nefedov_initial_conditions(SEXP internal_p, SEXP t_ptr) {
  nefedov_internal *internal = nefedov_get_internal(internal_p, 1);
  SEXP r_state = PROTECT(allocVector(REALSXP, 2));
  double * state = REAL(r_state);
  state[0] = internal->initial_N;
  state[1] = internal->initial_K;
  UNPROTECT(1);
  return r_state;
}
void nefedov_rhs(nefedov_internal* internal, double t, double * state, double * dstatedt, double * output) {
  double N = state[0];
  double K = state[1];
  dstatedt[0] = internal->r * N * (1 - N / (double) K);
  double harvest = internal->q * internal->food / (double) (internal->q - 1) * N / (double) (N + internal->food / (double) (internal->q - 1));
  dstatedt[1] = harvest - N;
}
void nefedov_rhs_dde(size_t neq, double t, double * state, double * dstatedt, void * internal) {
  nefedov_rhs((nefedov_internal*)internal, t, state, dstatedt, NULL);
}
void nefedov_rhs_desolve(int * neq, double * t, double * state, double * dstatedt, double * output, int * np) {
  nefedov_rhs(nefedov_internal_ds, *t, state, dstatedt, output);
}
SEXP nefedov_rhs_r(SEXP internal_p, SEXP t, SEXP state) {
  SEXP dstatedt = PROTECT(allocVector(REALSXP, LENGTH(state)));
  nefedov_internal *internal = nefedov_get_internal(internal_p, 1);
  double *output = NULL;
  nefedov_rhs(internal, scalar_real(t, "t"), REAL(state), REAL(dstatedt), output);
  UNPROTECT(1);
  return dstatedt;
}
scaling_cities_internal* scaling_cities_get_internal(SEXP internal_p, int closed_error) {
  scaling_cities_internal *internal = NULL;
  if (TYPEOF(internal_p) != EXTPTRSXP) {
    Rf_error("Expected an external pointer");
  }
  internal = (scaling_cities_internal*) R_ExternalPtrAddr(internal_p);
  if (!internal && closed_error) {
    Rf_error("Pointer has been invalidated");
  }
  return internal;
}
void scaling_cities_finalise(SEXP internal_p) {
  scaling_cities_internal *internal = scaling_cities_get_internal(internal_p, 0);
  if (internal_p) {
    R_Free(internal);
    R_ClearExternalPtr(internal_p);
  }
}
SEXP scaling_cities_create(SEXP user) {
  scaling_cities_internal *internal = (scaling_cities_internal*) R_Calloc(1, scaling_cities_internal);
  internal->initial_N = 1;
  internal->initial_Y = 1;
  internal->alpha = 0.90000000000000002;
  internal->beta = 1.1000000000000001;
  internal->E = 0.0001;
  internal->H = 9.9999999999999995e-07;
  internal->Im = 0;
  internal->K = 1;
  internal->M = 3.9999999999999998e-07;
  internal->r = 0.10000000000000001;
  internal->Tr = 0;
  SEXP ptr = PROTECT(R_MakeExternalPtr(internal, R_NilValue, R_NilValue));
  R_RegisterCFinalizer(ptr, scaling_cities_finalise);
  UNPROTECT(1);
  return ptr;
}
static scaling_cities_internal *scaling_cities_internal_ds;
void scaling_cities_initmod_desolve(void(* odeparms) (int *, double *)) {
  static DL_FUNC get_desolve_gparms = NULL;
  if (get_desolve_gparms == NULL) {
    get_desolve_gparms =
      R_GetCCallable("deSolve", "get_deSolve_gparms");
  }
  scaling_cities_internal_ds = scaling_cities_get_internal(get_desolve_gparms(), 1);
}
SEXP scaling_cities_contents(SEXP internal_p) {
  scaling_cities_internal *internal = scaling_cities_get_internal(internal_p, 1);
  SEXP contents = PROTECT(allocVector(VECSXP, 11));
  SET_VECTOR_ELT(contents, 0, ScalarReal(internal->alpha));
  SET_VECTOR_ELT(contents, 1, ScalarReal(internal->beta));
  SET_VECTOR_ELT(contents, 2, ScalarReal(internal->E));
  SET_VECTOR_ELT(contents, 3, ScalarReal(internal->H));
  SET_VECTOR_ELT(contents, 4, ScalarReal(internal->Im));
  SET_VECTOR_ELT(contents, 5, ScalarReal(internal->initial_N));
  SET_VECTOR_ELT(contents, 6, ScalarReal(internal->initial_Y));
  SET_VECTOR_ELT(contents, 7, ScalarReal(internal->K));
  SET_VECTOR_ELT(contents, 8, ScalarReal(internal->M));
  SET_VECTOR_ELT(contents, 9, ScalarReal(internal->r));
  SET_VECTOR_ELT(contents, 10, ScalarReal(internal->Tr));
  SEXP nms = PROTECT(allocVector(STRSXP, 11));
  SET_STRING_ELT(nms, 0, mkChar("alpha"));
  SET_STRING_ELT(nms, 1, mkChar("beta"));
  SET_STRING_ELT(nms, 2, mkChar("E"));
  SET_STRING_ELT(nms, 3, mkChar("H"));
  SET_STRING_ELT(nms, 4, mkChar("Im"));
  SET_STRING_ELT(nms, 5, mkChar("initial_N"));
  SET_STRING_ELT(nms, 6, mkChar("initial_Y"));
  SET_STRING_ELT(nms, 7, mkChar("K"));
  SET_STRING_ELT(nms, 8, mkChar("M"));
  SET_STRING_ELT(nms, 9, mkChar("r"));
  SET_STRING_ELT(nms, 10, mkChar("Tr"));
  setAttrib(contents, R_NamesSymbol, nms);
  UNPROTECT(2);
  return contents;
}
SEXP scaling_cities_set_user(SEXP internal_p, SEXP user) {
  scaling_cities_internal *internal = scaling_cities_get_internal(internal_p, 1);
  internal->alpha = user_get_scalar_double(user, "alpha", internal->alpha, NA_REAL, NA_REAL);
  internal->beta = user_get_scalar_double(user, "beta", internal->beta, NA_REAL, NA_REAL);
  internal->E = user_get_scalar_double(user, "E", internal->E, NA_REAL, NA_REAL);
  internal->H = user_get_scalar_double(user, "H", internal->H, NA_REAL, NA_REAL);
  internal->Im = user_get_scalar_double(user, "Im", internal->Im, NA_REAL, NA_REAL);
  internal->K = user_get_scalar_double(user, "K", internal->K, NA_REAL, NA_REAL);
  internal->M = user_get_scalar_double(user, "M", internal->M, NA_REAL, NA_REAL);
  internal->r = user_get_scalar_double(user, "r", internal->r, NA_REAL, NA_REAL);
  internal->Tr = user_get_scalar_double(user, "Tr", internal->Tr, NA_REAL, NA_REAL);
  return R_NilValue;
}
SEXP scaling_cities_set_initial(SEXP internal_p, SEXP t_ptr, SEXP state_ptr, SEXP scaling_cities_use_dde_ptr) {
  return R_NilValue;
}
SEXP scaling_cities_metadata(SEXP internal_p) {
  scaling_cities_internal *internal = scaling_cities_get_internal(internal_p, 1);
  SEXP ret = PROTECT(allocVector(VECSXP, 4));
  SEXP nms = PROTECT(allocVector(STRSXP, 4));
  SET_STRING_ELT(nms, 0, mkChar("variable_order"));
  SET_STRING_ELT(nms, 1, mkChar("output_order"));
  SET_STRING_ELT(nms, 2, mkChar("n_out"));
  SET_STRING_ELT(nms, 3, mkChar("interpolate_t"));
  setAttrib(ret, R_NamesSymbol, nms);
  SEXP variable_length = PROTECT(allocVector(VECSXP, 2));
  SEXP variable_names = PROTECT(allocVector(STRSXP, 2));
  setAttrib(variable_length, R_NamesSymbol, variable_names);
  SET_VECTOR_ELT(variable_length, 0, R_NilValue);
  SET_VECTOR_ELT(variable_length, 1, R_NilValue);
  SET_STRING_ELT(variable_names, 0, mkChar("Y"));
  SET_STRING_ELT(variable_names, 1, mkChar("N"));
  SET_VECTOR_ELT(ret, 0, variable_length);
  UNPROTECT(2);
  SET_VECTOR_ELT(ret, 1, R_NilValue);
  SET_VECTOR_ELT(ret, 2, ScalarInteger(0));
  UNPROTECT(2);
  return ret;
}
SEXP scaling_cities_initial_conditions(SEXP internal_p, SEXP t_ptr) {
  scaling_cities_internal *internal = scaling_cities_get_internal(internal_p, 1);
  SEXP r_state = PROTECT(allocVector(REALSXP, 2));
  double * state = REAL(r_state);
  state[0] = internal->initial_Y;
  state[1] = internal->initial_N;
  UNPROTECT(1);
  return r_state;
}
void scaling_cities_rhs(scaling_cities_internal* internal, double t, double * state, double * dstatedt, double * output) {
  double Y = state[0];
  double N = state[1];
  dstatedt[1] = internal->H / (double) internal->E * Y * pow(N, internal->beta) - internal->M / (double) internal->E * pow(N, internal->alpha) + internal->Im;
  dstatedt[0] = internal->r * Y * (1 - Y / (double) internal->K) - Y * internal->H * pow(N, internal->beta) + internal->Tr;
}
void scaling_cities_rhs_dde(size_t neq, double t, double * state, double * dstatedt, void * internal) {
  scaling_cities_rhs((scaling_cities_internal*)internal, t, state, dstatedt, NULL);
}
void scaling_cities_rhs_desolve(int * neq, double * t, double * state, double * dstatedt, double * output, int * np) {
  scaling_cities_rhs(scaling_cities_internal_ds, *t, state, dstatedt, output);
}
SEXP scaling_cities_rhs_r(SEXP internal_p, SEXP t, SEXP state) {
  SEXP dstatedt = PROTECT(allocVector(REALSXP, LENGTH(state)));
  scaling_cities_internal *internal = scaling_cities_get_internal(internal_p, 1);
  double *output = NULL;
  scaling_cities_rhs(internal, scalar_real(t, "t"), REAL(state), REAL(dstatedt), output);
  UNPROTECT(1);
  return dstatedt;
}
stateless_war_internal* stateless_war_get_internal(SEXP internal_p, int closed_error) {
  stateless_war_internal *internal = NULL;
  if (TYPEOF(internal_p) != EXTPTRSXP) {
    Rf_error("Expected an external pointer");
  }
  internal = (stateless_war_internal*) R_ExternalPtrAddr(internal_p);
  if (!internal && closed_error) {
    Rf_error("Pointer has been invalidated");
  }
  return internal;
}
void stateless_war_finalise(SEXP internal_p) {
  stateless_war_internal *internal = stateless_war_get_internal(internal_p, 0);
  if (internal_p) {
    R_Free(internal);
    R_ClearExternalPtr(internal_p);
  }
}
SEXP stateless_war_create(SEXP user) {
  stateless_war_internal *internal = (stateless_war_internal*) R_Calloc(1, stateless_war_internal);
  internal->initial_N = 0.5;
  internal->initial_W = 0;
  internal->K = 1;
  internal->a = 0.01;
  internal->b = 0.050000000000000003;
  internal->c = 1;
  internal->kmax = 3;
  internal->r = 0.014999999999999999;
  SEXP ptr = PROTECT(R_MakeExternalPtr(internal, R_NilValue, R_NilValue));
  R_RegisterCFinalizer(ptr, stateless_war_finalise);
  UNPROTECT(1);
  return ptr;
}
static stateless_war_internal *stateless_war_internal_ds;
void stateless_war_initmod_desolve(void(* odeparms) (int *, double *)) {
  static DL_FUNC get_desolve_gparms = NULL;
  if (get_desolve_gparms == NULL) {
    get_desolve_gparms =
      R_GetCCallable("deSolve", "get_deSolve_gparms");
  }
  stateless_war_internal_ds = stateless_war_get_internal(get_desolve_gparms(), 1);
}
SEXP stateless_war_contents(SEXP internal_p) {
  stateless_war_internal *internal = stateless_war_get_internal(internal_p, 1);
  SEXP contents = PROTECT(allocVector(VECSXP, 8));
  SET_VECTOR_ELT(contents, 0, ScalarReal(internal->a));
  SET_VECTOR_ELT(contents, 1, ScalarReal(internal->b));
  SET_VECTOR_ELT(contents, 2, ScalarReal(internal->c));
  SET_VECTOR_ELT(contents, 3, ScalarReal(internal->initial_N));
  SET_VECTOR_ELT(contents, 4, ScalarReal(internal->initial_W));
  SET_VECTOR_ELT(contents, 5, ScalarReal(internal->K));
  SET_VECTOR_ELT(contents, 6, ScalarReal(internal->kmax));
  SET_VECTOR_ELT(contents, 7, ScalarReal(internal->r));
  SEXP nms = PROTECT(allocVector(STRSXP, 8));
  SET_STRING_ELT(nms, 0, mkChar("a"));
  SET_STRING_ELT(nms, 1, mkChar("b"));
  SET_STRING_ELT(nms, 2, mkChar("c"));
  SET_STRING_ELT(nms, 3, mkChar("initial_N"));
  SET_STRING_ELT(nms, 4, mkChar("initial_W"));
  SET_STRING_ELT(nms, 5, mkChar("K"));
  SET_STRING_ELT(nms, 6, mkChar("kmax"));
  SET_STRING_ELT(nms, 7, mkChar("r"));
  setAttrib(contents, R_NamesSymbol, nms);
  UNPROTECT(2);
  return contents;
}
SEXP stateless_war_set_user(SEXP internal_p, SEXP user) {
  stateless_war_internal *internal = stateless_war_get_internal(internal_p, 1);
  internal->a = user_get_scalar_double(user, "a", internal->a, NA_REAL, NA_REAL);
  internal->b = user_get_scalar_double(user, "b", internal->b, NA_REAL, NA_REAL);
  internal->c = user_get_scalar_double(user, "c", internal->c, NA_REAL, NA_REAL);
  internal->kmax = user_get_scalar_double(user, "kmax", internal->kmax, NA_REAL, NA_REAL);
  internal->r = user_get_scalar_double(user, "r", internal->r, NA_REAL, NA_REAL);
  return R_NilValue;
}
SEXP stateless_war_set_initial(SEXP internal_p, SEXP t_ptr, SEXP state_ptr, SEXP stateless_war_use_dde_ptr) {
  return R_NilValue;
}
SEXP stateless_war_metadata(SEXP internal_p) {
  stateless_war_internal *internal = stateless_war_get_internal(internal_p, 1);
  SEXP ret = PROTECT(allocVector(VECSXP, 4));
  SEXP nms = PROTECT(allocVector(STRSXP, 4));
  SET_STRING_ELT(nms, 0, mkChar("variable_order"));
  SET_STRING_ELT(nms, 1, mkChar("output_order"));
  SET_STRING_ELT(nms, 2, mkChar("n_out"));
  SET_STRING_ELT(nms, 3, mkChar("interpolate_t"));
  setAttrib(ret, R_NamesSymbol, nms);
  SEXP variable_length = PROTECT(allocVector(VECSXP, 2));
  SEXP variable_names = PROTECT(allocVector(STRSXP, 2));
  setAttrib(variable_length, R_NamesSymbol, variable_names);
  SET_VECTOR_ELT(variable_length, 0, R_NilValue);
  SET_VECTOR_ELT(variable_length, 1, R_NilValue);
  SET_STRING_ELT(variable_names, 0, mkChar("N"));
  SET_STRING_ELT(variable_names, 1, mkChar("W"));
  SET_VECTOR_ELT(ret, 0, variable_length);
  UNPROTECT(2);
  SET_VECTOR_ELT(ret, 1, R_NilValue);
  SET_VECTOR_ELT(ret, 2, ScalarInteger(0));
  UNPROTECT(2);
  return ret;
}
SEXP stateless_war_initial_conditions(SEXP internal_p, SEXP t_ptr) {
  stateless_war_internal *internal = stateless_war_get_internal(internal_p, 1);
  SEXP r_state = PROTECT(allocVector(REALSXP, 2));
  double * state = REAL(r_state);
  state[0] = internal->initial_N;
  state[1] = internal->initial_W;
  UNPROTECT(1);
  return r_state;
}
void stateless_war_rhs(stateless_war_internal* internal, double t, double * state, double * dstatedt, double * output) {
  double N = state[0];
  double W = state[1];
  dstatedt[0] = internal->r * N * (1 - N / (double) internal->K) - N * W;
  dstatedt[1] = (internal->a * pow(N, 2) - internal->b * W);
}
void stateless_war_rhs_dde(size_t neq, double t, double * state, double * dstatedt, void * internal) {
  stateless_war_rhs((stateless_war_internal*)internal, t, state, dstatedt, NULL);
}
void stateless_war_rhs_desolve(int * neq, double * t, double * state, double * dstatedt, double * output, int * np) {
  stateless_war_rhs(stateless_war_internal_ds, *t, state, dstatedt, output);
}
SEXP stateless_war_rhs_r(SEXP internal_p, SEXP t, SEXP state) {
  SEXP dstatedt = PROTECT(allocVector(REALSXP, LENGTH(state)));
  stateless_war_internal *internal = stateless_war_get_internal(internal_p, 1);
  double *output = NULL;
  stateless_war_rhs(internal, scalar_real(t, "t"), REAL(state), REAL(dstatedt), output);
  UNPROTECT(1);
  return dstatedt;
}
double user_get_scalar_double(SEXP user, const char *name,
                              double default_value, double min, double max) {
  double ret = default_value;
  SEXP el = user_list_element(user, name);
  if (el != R_NilValue) {
    if (length(el) != 1) {
      Rf_error("Expected a scalar numeric for '%s'", name);
    }
    if (TYPEOF(el) == REALSXP) {
      ret = REAL(el)[0];
    } else if (TYPEOF(el) == INTSXP) {
      ret = INTEGER(el)[0];
    } else {
      Rf_error("Expected a numeric value for '%s'", name);
    }
  }
  if (ISNA(ret)) {
    Rf_error("Expected a value for '%s'", name);
  }
  user_check_values_double(&ret, 1, min, max, name);
  return ret;
}
int user_get_scalar_int(SEXP user, const char *name,
                        int default_value, double min, double max) {
  int ret = default_value;
  SEXP el = user_list_element(user, name);
  if (el != R_NilValue) {
    if (length(el) != 1) {
      Rf_error("Expected scalar integer for '%d'", name);
    }
    if (TYPEOF(el) == REALSXP) {
      double tmp = REAL(el)[0];
      if (fabs(tmp - round(tmp)) > 2e-8) {
        Rf_error("Expected '%s' to be integer-like", name);
      }
    }
    ret = INTEGER(coerceVector(el, INTSXP))[0];
  }
  if (ret == NA_INTEGER) {
    Rf_error("Expected a value for '%s'", name);
  }
  user_check_values_int(&ret, 1, min, max, name);
  return ret;
}
void user_check_values_double(double * value, size_t len,
                                  double min, double max, const char *name) {
  for (size_t i = 0; i < len; ++i) {
    if (ISNA(value[i])) {
      Rf_error("'%s' must not contain any NA values", name);
    }
  }
  if (min != NA_REAL) {
    for (size_t i = 0; i < len; ++i) {
      if (value[i] < min) {
        Rf_error("Expected '%s' to be at least %g", name, min);
      }
    }
  }
  if (max != NA_REAL) {
    for (size_t i = 0; i < len; ++i) {
      if (value[i] > max) {
        Rf_error("Expected '%s' to be at most %g", name, max);
      }
    }
  }
}
void user_check_values_int(int * value, size_t len,
                               double min, double max, const char *name) {
  for (size_t i = 0; i < len; ++i) {
    if (ISNA(value[i])) {
      Rf_error("'%s' must not contain any NA values", name);
    }
  }
  if (min != NA_REAL) {
    for (size_t i = 0; i < len; ++i) {
      if (value[i] < min) {
        Rf_error("Expected '%s' to be at least %g", name, min);
      }
    }
  }
  if (max != NA_REAL) {
    for (size_t i = 0; i < len; ++i) {
      if (value[i] > max) {
        Rf_error("Expected '%s' to be at most %g", name, max);
      }
    }
  }
}
void user_check_values(SEXP value, double min, double max,
                           const char *name) {
  size_t len = (size_t)length(value);
  if (TYPEOF(value) == INTSXP) {
    user_check_values_int(INTEGER(value), len, min, max, name);
  } else {
    user_check_values_double(REAL(value), len, min, max, name);
  }
}
SEXP user_list_element(SEXP list, const char *name) {
  SEXP ret = R_NilValue, names = getAttrib(list, R_NamesSymbol);
  for (int i = 0; i < length(list); ++i) {
    if (strcmp(CHAR(STRING_ELT(names, i)), name) == 0) {
      ret = VECTOR_ELT(list, i);
      break;
    }
  }
  return ret;
}
double scalar_real(SEXP x, const char * name) {
  if (Rf_length(x) != 1) {
    Rf_error("Expected a scalar for '%s'", name);
  }
  double ret = 0.0;
  if (TYPEOF(x) == INTSXP) {
    ret = INTEGER(x)[0];
  } else if (TYPEOF(x) == REALSXP) {
    ret = REAL(x)[0];
  } else {
    Rf_error("Expected a numeric value for '%s'", name);
  }
  return ret;
}
