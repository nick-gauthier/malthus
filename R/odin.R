## Automatically generated by odin 1.5.4 - do not edit
elite_extraction_ <- R6::R6Class(
  "odin_model",
  cloneable = FALSE,

  private = list(
    ptr = NULL,
    use_dde = NULL,

    odin = NULL,
    variable_order = NULL,
    output_order = NULL,
    n_out = NULL,
    ynames = NULL,
    interpolate_t = NULL,
    cfuns = list(
      rhs_dde = "elite_extraction_rhs_dde",
      rhs_desolve = "elite_extraction_rhs_desolve",
      initmod_desolve = "elite_extraction_initmod_desolve"),
    dll = "malthus",
    user = c("a", "beta1", "beta2", "delta1", "delta2", "epsilon", "g",
             "rho0"),

    ## This is never called, but is used to ensure that R finds our
    ## symbols that we will use from the package; without this they
    ## cannot be found by dynamic lookup now that we use the package
    ## FFI registration system.
    registration = function() {
      if (FALSE) {
        .C("elite_extraction_rhs_dde", package = "malthus")
        .C("elite_extraction_rhs_desolve", package = "malthus")
        .C("elite_extraction_initmod_desolve", package = "malthus")
      }
    },

    ## This only does something in delay models
    set_initial = function(t, y, use_dde) {
      .Call("elite_extraction_set_initial", private$ptr, t, y, use_dde,
            PACKAGE= "malthus")
    },

    update_metadata = function() {
      meta <- .Call("elite_extraction_metadata", private$ptr,
                    PACKAGE = "malthus")
      private$variable_order <- meta$variable_order
      private$output_order <- meta$output_order
      private$n_out <- meta$n_out
      private$ynames <- private$odin$make_names(
        private$variable_order, private$output_order, FALSE)
      private$interpolate_t <- meta$interpolate_t
    }
  ),

  public = list(
    initialize = function(..., user = list(...), use_dde = FALSE,
                          unused_user_action = NULL) {
      private$odin <- asNamespace("odin")
      private$ptr <- .Call("elite_extraction_create", user, PACKAGE = "malthus")
      self$set_user(user = user, unused_user_action = unused_user_action)
      private$use_dde <- use_dde
      private$update_metadata()
    },

    ir = function() {
      path_ir <- system.file("odin/elite_extraction.json", mustWork = TRUE,
                             package = "malthus")
      json <- readLines(path_ir)
      class(json) <- "json"
      json
    },

    ## Do we need to have the user-settable args here? It would be
    ## nice, but that's not super straightforward to do.
    set_user = function(..., user = list(...), unused_user_action = NULL) {
      private$odin$support_check_user(user, private$user, unused_user_action)
      .Call("elite_extraction_set_user", private$ptr, user, PACKAGE = "malthus")
      private$update_metadata()
    },

    ## This might be time sensitive and, so we can avoid computing
    ## it. I wonder if that's an optimisation we should drop for now
    ## as it does not seem generally useful. This would bring us
    ## closer to the js version which requires that we always pass the
    ## time in.
    initial = function(t) {
      .Call("elite_extraction_initial_conditions", private$ptr, t, PACKAGE = "malthus")
    },

    rhs = function(t, y) {
      .Call("elite_extraction_rhs_r", private$ptr, t, y, PACKAGE = "malthus")
    },

    deriv = function(t, y) {
      self$rhs(t, y)
    },

    contents = function() {
      .Call("elite_extraction_contents", private$ptr, PACKAGE = "malthus")
    },

    transform_variables = function(y) {
      private$odin$support_transform_variables(y, private)
    },

    engine = function() {
      "c"
    },

    run = function(t, y = NULL, ..., use_names = TRUE) {
      private$odin$wrapper_run_ode(
        self, private, t, y, ..., use_names = use_names)
    }
  ))


elite_extraction <- function(..., user = list(...), use_dde = FALSE,
                     unused_user_action = NULL) {
  asNamespace("odin")$deprecated_constructor_call("elite_extraction")
  elite_extraction_$new(user = user, use_dde = use_dde,
                unused_user_action = unused_user_action)
}
class(elite_extraction) <- "odin_generator"
attr(elite_extraction, "generator") <- elite_extraction_
fiscal_demographic_class_ <- R6::R6Class(
  "odin_model",
  cloneable = FALSE,

  private = list(
    ptr = NULL,
    use_dde = NULL,

    odin = NULL,
    variable_order = NULL,
    output_order = NULL,
    n_out = NULL,
    ynames = NULL,
    interpolate_t = NULL,
    cfuns = list(
      rhs_dde = "fiscal_demographic_class_rhs_dde",
      rhs_desolve = "fiscal_demographic_class_rhs_desolve",
      initmod_desolve = "fiscal_demographic_class_initmod_desolve"),
    dll = "malthus",
    user = c("a", "alpha", "beta1", "beta2", "c", "delta1", "delta2", "E0",
             "epsilon", "g0", "gamma", "h", "P0", "rho0", "S0"),

    ## This is never called, but is used to ensure that R finds our
    ## symbols that we will use from the package; without this they
    ## cannot be found by dynamic lookup now that we use the package
    ## FFI registration system.
    registration = function() {
      if (FALSE) {
        .C("fiscal_demographic_class_rhs_dde", package = "malthus")
        .C("fiscal_demographic_class_rhs_desolve", package = "malthus")
        .C("fiscal_demographic_class_initmod_desolve", package = "malthus")
      }
    },

    ## This only does something in delay models
    set_initial = function(t, y, use_dde) {
      .Call("fiscal_demographic_class_set_initial", private$ptr, t, y, use_dde,
            PACKAGE= "malthus")
    },

    update_metadata = function() {
      meta <- .Call("fiscal_demographic_class_metadata", private$ptr,
                    PACKAGE = "malthus")
      private$variable_order <- meta$variable_order
      private$output_order <- meta$output_order
      private$n_out <- meta$n_out
      private$ynames <- private$odin$make_names(
        private$variable_order, private$output_order, FALSE)
      private$interpolate_t <- meta$interpolate_t
    }
  ),

  public = list(
    initialize = function(..., user = list(...), use_dde = FALSE,
                          unused_user_action = NULL) {
      private$odin <- asNamespace("odin")
      private$ptr <- .Call("fiscal_demographic_class_create", user, PACKAGE = "malthus")
      self$set_user(user = user, unused_user_action = unused_user_action)
      private$use_dde <- use_dde
      private$update_metadata()
    },

    ir = function() {
      path_ir <- system.file("odin/fiscal_demographic_class.json", mustWork = TRUE,
                             package = "malthus")
      json <- readLines(path_ir)
      class(json) <- "json"
      json
    },

    ## Do we need to have the user-settable args here? It would be
    ## nice, but that's not super straightforward to do.
    set_user = function(..., user = list(...), unused_user_action = NULL) {
      private$odin$support_check_user(user, private$user, unused_user_action)
      .Call("fiscal_demographic_class_set_user", private$ptr, user, PACKAGE = "malthus")
      private$update_metadata()
    },

    ## This might be time sensitive and, so we can avoid computing
    ## it. I wonder if that's an optimisation we should drop for now
    ## as it does not seem generally useful. This would bring us
    ## closer to the js version which requires that we always pass the
    ## time in.
    initial = function(t) {
      .Call("fiscal_demographic_class_initial_conditions", private$ptr, t, PACKAGE = "malthus")
    },

    rhs = function(t, y) {
      .Call("fiscal_demographic_class_rhs_r", private$ptr, t, y, PACKAGE = "malthus")
    },

    deriv = function(t, y) {
      self$rhs(t, y)
    },

    contents = function() {
      .Call("fiscal_demographic_class_contents", private$ptr, PACKAGE = "malthus")
    },

    transform_variables = function(y) {
      private$odin$support_transform_variables(y, private)
    },

    engine = function() {
      "c"
    },

    run = function(t, y = NULL, ..., use_names = TRUE) {
      private$odin$wrapper_run_ode(
        self, private, t, y, ..., use_names = use_names)
    }
  ))


fiscal_demographic_class <- function(..., user = list(...), use_dde = FALSE,
                     unused_user_action = NULL) {
  asNamespace("odin")$deprecated_constructor_call("fiscal_demographic_class")
  fiscal_demographic_class_$new(user = user, use_dde = use_dde,
                unused_user_action = unused_user_action)
}
class(fiscal_demographic_class) <- "odin_generator"
attr(fiscal_demographic_class, "generator") <- fiscal_demographic_class_
fiscal_demographic_war_ <- R6::R6Class(
  "odin_model",
  cloneable = FALSE,

  private = list(
    ptr = NULL,
    use_dde = NULL,

    odin = NULL,
    variable_order = NULL,
    output_order = NULL,
    n_out = NULL,
    ynames = NULL,
    interpolate_t = NULL,
    cfuns = list(
      rhs_dde = "fiscal_demographic_war_rhs_dde",
      rhs_desolve = "fiscal_demographic_war_rhs_desolve",
      initmod_desolve = "fiscal_demographic_war_initmod_desolve"),
    dll = "malthus",
    user = c("a", "alpha", "b", "beta", "c", "delta", "kmax", "N0", "r",
             "rho", "S0", "W0"),

    ## This is never called, but is used to ensure that R finds our
    ## symbols that we will use from the package; without this they
    ## cannot be found by dynamic lookup now that we use the package
    ## FFI registration system.
    registration = function() {
      if (FALSE) {
        .C("fiscal_demographic_war_rhs_dde", package = "malthus")
        .C("fiscal_demographic_war_rhs_desolve", package = "malthus")
        .C("fiscal_demographic_war_initmod_desolve", package = "malthus")
      }
    },

    ## This only does something in delay models
    set_initial = function(t, y, use_dde) {
      .Call("fiscal_demographic_war_set_initial", private$ptr, t, y, use_dde,
            PACKAGE= "malthus")
    },

    update_metadata = function() {
      meta <- .Call("fiscal_demographic_war_metadata", private$ptr,
                    PACKAGE = "malthus")
      private$variable_order <- meta$variable_order
      private$output_order <- meta$output_order
      private$n_out <- meta$n_out
      private$ynames <- private$odin$make_names(
        private$variable_order, private$output_order, FALSE)
      private$interpolate_t <- meta$interpolate_t
    }
  ),

  public = list(
    initialize = function(..., user = list(...), use_dde = FALSE,
                          unused_user_action = NULL) {
      private$odin <- asNamespace("odin")
      private$ptr <- .Call("fiscal_demographic_war_create", user, PACKAGE = "malthus")
      self$set_user(user = user, unused_user_action = unused_user_action)
      private$use_dde <- use_dde
      private$update_metadata()
    },

    ir = function() {
      path_ir <- system.file("odin/fiscal_demographic_war.json", mustWork = TRUE,
                             package = "malthus")
      json <- readLines(path_ir)
      class(json) <- "json"
      json
    },

    ## Do we need to have the user-settable args here? It would be
    ## nice, but that's not super straightforward to do.
    set_user = function(..., user = list(...), unused_user_action = NULL) {
      private$odin$support_check_user(user, private$user, unused_user_action)
      .Call("fiscal_demographic_war_set_user", private$ptr, user, PACKAGE = "malthus")
      private$update_metadata()
    },

    ## This might be time sensitive and, so we can avoid computing
    ## it. I wonder if that's an optimisation we should drop for now
    ## as it does not seem generally useful. This would bring us
    ## closer to the js version which requires that we always pass the
    ## time in.
    initial = function(t) {
      .Call("fiscal_demographic_war_initial_conditions", private$ptr, t, PACKAGE = "malthus")
    },

    rhs = function(t, y) {
      .Call("fiscal_demographic_war_rhs_r", private$ptr, t, y, PACKAGE = "malthus")
    },

    deriv = function(t, y) {
      self$rhs(t, y)
    },

    contents = function() {
      .Call("fiscal_demographic_war_contents", private$ptr, PACKAGE = "malthus")
    },

    transform_variables = function(y) {
      private$odin$support_transform_variables(y, private)
    },

    engine = function() {
      "c"
    },

    run = function(t, y = NULL, ..., use_names = TRUE) {
      private$odin$wrapper_run_ode(
        self, private, t, y, ..., use_names = use_names)
    }
  ))


fiscal_demographic_war <- function(..., user = list(...), use_dde = FALSE,
                     unused_user_action = NULL) {
  asNamespace("odin")$deprecated_constructor_call("fiscal_demographic_war")
  fiscal_demographic_war_$new(user = user, use_dde = use_dde,
                unused_user_action = unused_user_action)
}
class(fiscal_demographic_war) <- "odin_generator"
attr(fiscal_demographic_war, "generator") <- fiscal_demographic_war_
fiscal_demographic_ <- R6::R6Class(
  "odin_model",
  cloneable = FALSE,

  private = list(
    ptr = NULL,
    use_dde = NULL,

    odin = NULL,
    variable_order = NULL,
    output_order = NULL,
    n_out = NULL,
    ynames = NULL,
    interpolate_t = NULL,
    cfuns = list(
      rhs_dde = "fiscal_demographic_rhs_dde",
      rhs_desolve = "fiscal_demographic_rhs_desolve",
      initmod_desolve = "fiscal_demographic_initmod_desolve"),
    dll = "malthus",
    user = c("beta", "c", "r", "s0"),

    ## This is never called, but is used to ensure that R finds our
    ## symbols that we will use from the package; without this they
    ## cannot be found by dynamic lookup now that we use the package
    ## FFI registration system.
    registration = function() {
      if (FALSE) {
        .C("fiscal_demographic_rhs_dde", package = "malthus")
        .C("fiscal_demographic_rhs_desolve", package = "malthus")
        .C("fiscal_demographic_initmod_desolve", package = "malthus")
      }
    },

    ## This only does something in delay models
    set_initial = function(t, y, use_dde) {
      .Call("fiscal_demographic_set_initial", private$ptr, t, y, use_dde,
            PACKAGE= "malthus")
    },

    update_metadata = function() {
      meta <- .Call("fiscal_demographic_metadata", private$ptr,
                    PACKAGE = "malthus")
      private$variable_order <- meta$variable_order
      private$output_order <- meta$output_order
      private$n_out <- meta$n_out
      private$ynames <- private$odin$make_names(
        private$variable_order, private$output_order, FALSE)
      private$interpolate_t <- meta$interpolate_t
    }
  ),

  public = list(
    initialize = function(..., user = list(...), use_dde = FALSE,
                          unused_user_action = NULL) {
      private$odin <- asNamespace("odin")
      private$ptr <- .Call("fiscal_demographic_create", user, PACKAGE = "malthus")
      self$set_user(user = user, unused_user_action = unused_user_action)
      private$use_dde <- use_dde
      private$update_metadata()
    },

    ir = function() {
      path_ir <- system.file("odin/fiscal_demographic.json", mustWork = TRUE,
                             package = "malthus")
      json <- readLines(path_ir)
      class(json) <- "json"
      json
    },

    ## Do we need to have the user-settable args here? It would be
    ## nice, but that's not super straightforward to do.
    set_user = function(..., user = list(...), unused_user_action = NULL) {
      private$odin$support_check_user(user, private$user, unused_user_action)
      .Call("fiscal_demographic_set_user", private$ptr, user, PACKAGE = "malthus")
      private$update_metadata()
    },

    ## This might be time sensitive and, so we can avoid computing
    ## it. I wonder if that's an optimisation we should drop for now
    ## as it does not seem generally useful. This would bring us
    ## closer to the js version which requires that we always pass the
    ## time in.
    initial = function(t) {
      .Call("fiscal_demographic_initial_conditions", private$ptr, t, PACKAGE = "malthus")
    },

    rhs = function(t, y) {
      .Call("fiscal_demographic_rhs_r", private$ptr, t, y, PACKAGE = "malthus")
    },

    deriv = function(t, y) {
      self$rhs(t, y)
    },

    contents = function() {
      .Call("fiscal_demographic_contents", private$ptr, PACKAGE = "malthus")
    },

    transform_variables = function(y) {
      private$odin$support_transform_variables(y, private)
    },

    engine = function() {
      "c"
    },

    run = function(t, y = NULL, ..., use_names = TRUE) {
      private$odin$wrapper_run_ode(
        self, private, t, y, ..., use_names = use_names)
    }
  ))


fiscal_demographic <- function(..., user = list(...), use_dde = FALSE,
                     unused_user_action = NULL) {
  asNamespace("odin")$deprecated_constructor_call("fiscal_demographic")
  fiscal_demographic_$new(user = user, use_dde = use_dde,
                unused_user_action = unused_user_action)
}
class(fiscal_demographic) <- "odin_generator"
attr(fiscal_demographic, "generator") <- fiscal_demographic_
nefedov_ <- R6::R6Class(
  "odin_model",
  cloneable = FALSE,

  private = list(
    ptr = NULL,
    use_dde = NULL,

    odin = NULL,
    variable_order = NULL,
    output_order = NULL,
    n_out = NULL,
    ynames = NULL,
    interpolate_t = NULL,
    cfuns = list(
      rhs_dde = "nefedov_rhs_dde",
      rhs_desolve = "nefedov_rhs_desolve",
      initmod_desolve = "nefedov_initmod_desolve"),
    dll = "malthus",
    user = c("food", "K0", "N0", "q", "r"),

    ## This is never called, but is used to ensure that R finds our
    ## symbols that we will use from the package; without this they
    ## cannot be found by dynamic lookup now that we use the package
    ## FFI registration system.
    registration = function() {
      if (FALSE) {
        .C("nefedov_rhs_dde", package = "malthus")
        .C("nefedov_rhs_desolve", package = "malthus")
        .C("nefedov_initmod_desolve", package = "malthus")
      }
    },

    ## This only does something in delay models
    set_initial = function(t, y, use_dde) {
      .Call("nefedov_set_initial", private$ptr, t, y, use_dde,
            PACKAGE= "malthus")
    },

    update_metadata = function() {
      meta <- .Call("nefedov_metadata", private$ptr,
                    PACKAGE = "malthus")
      private$variable_order <- meta$variable_order
      private$output_order <- meta$output_order
      private$n_out <- meta$n_out
      private$ynames <- private$odin$make_names(
        private$variable_order, private$output_order, FALSE)
      private$interpolate_t <- meta$interpolate_t
    }
  ),

  public = list(
    initialize = function(..., user = list(...), use_dde = FALSE,
                          unused_user_action = NULL) {
      private$odin <- asNamespace("odin")
      private$ptr <- .Call("nefedov_create", user, PACKAGE = "malthus")
      self$set_user(user = user, unused_user_action = unused_user_action)
      private$use_dde <- use_dde
      private$update_metadata()
    },

    ir = function() {
      path_ir <- system.file("odin/nefedov.json", mustWork = TRUE,
                             package = "malthus")
      json <- readLines(path_ir)
      class(json) <- "json"
      json
    },

    ## Do we need to have the user-settable args here? It would be
    ## nice, but that's not super straightforward to do.
    set_user = function(..., user = list(...), unused_user_action = NULL) {
      private$odin$support_check_user(user, private$user, unused_user_action)
      .Call("nefedov_set_user", private$ptr, user, PACKAGE = "malthus")
      private$update_metadata()
    },

    ## This might be time sensitive and, so we can avoid computing
    ## it. I wonder if that's an optimisation we should drop for now
    ## as it does not seem generally useful. This would bring us
    ## closer to the js version which requires that we always pass the
    ## time in.
    initial = function(t) {
      .Call("nefedov_initial_conditions", private$ptr, t, PACKAGE = "malthus")
    },

    rhs = function(t, y) {
      .Call("nefedov_rhs_r", private$ptr, t, y, PACKAGE = "malthus")
    },

    deriv = function(t, y) {
      self$rhs(t, y)
    },

    contents = function() {
      .Call("nefedov_contents", private$ptr, PACKAGE = "malthus")
    },

    transform_variables = function(y) {
      private$odin$support_transform_variables(y, private)
    },

    engine = function() {
      "c"
    },

    run = function(t, y = NULL, ..., use_names = TRUE) {
      private$odin$wrapper_run_ode(
        self, private, t, y, ..., use_names = use_names)
    }
  ))


nefedov <- function(..., user = list(...), use_dde = FALSE,
                     unused_user_action = NULL) {
  asNamespace("odin")$deprecated_constructor_call("nefedov")
  nefedov_$new(user = user, use_dde = use_dde,
                unused_user_action = unused_user_action)
}
class(nefedov) <- "odin_generator"
attr(nefedov, "generator") <- nefedov_
scaling_cities_ <- R6::R6Class(
  "odin_model",
  cloneable = FALSE,

  private = list(
    ptr = NULL,
    use_dde = NULL,

    odin = NULL,
    variable_order = NULL,
    output_order = NULL,
    n_out = NULL,
    ynames = NULL,
    interpolate_t = NULL,
    cfuns = list(
      rhs_dde = "scaling_cities_rhs_dde",
      rhs_desolve = "scaling_cities_rhs_desolve",
      initmod_desolve = "scaling_cities_initmod_desolve"),
    dll = "malthus",
    user = c("alpha", "beta", "H", "Im", "M", "N0", "Tr", "Y0"),

    ## This is never called, but is used to ensure that R finds our
    ## symbols that we will use from the package; without this they
    ## cannot be found by dynamic lookup now that we use the package
    ## FFI registration system.
    registration = function() {
      if (FALSE) {
        .C("scaling_cities_rhs_dde", package = "malthus")
        .C("scaling_cities_rhs_desolve", package = "malthus")
        .C("scaling_cities_initmod_desolve", package = "malthus")
      }
    },

    ## This only does something in delay models
    set_initial = function(t, y, use_dde) {
      .Call("scaling_cities_set_initial", private$ptr, t, y, use_dde,
            PACKAGE= "malthus")
    },

    update_metadata = function() {
      meta <- .Call("scaling_cities_metadata", private$ptr,
                    PACKAGE = "malthus")
      private$variable_order <- meta$variable_order
      private$output_order <- meta$output_order
      private$n_out <- meta$n_out
      private$ynames <- private$odin$make_names(
        private$variable_order, private$output_order, FALSE)
      private$interpolate_t <- meta$interpolate_t
    }
  ),

  public = list(
    initialize = function(..., user = list(...), use_dde = FALSE,
                          unused_user_action = NULL) {
      private$odin <- asNamespace("odin")
      private$ptr <- .Call("scaling_cities_create", user, PACKAGE = "malthus")
      self$set_user(user = user, unused_user_action = unused_user_action)
      private$use_dde <- use_dde
      private$update_metadata()
    },

    ir = function() {
      path_ir <- system.file("odin/scaling_cities.json", mustWork = TRUE,
                             package = "malthus")
      json <- readLines(path_ir)
      class(json) <- "json"
      json
    },

    ## Do we need to have the user-settable args here? It would be
    ## nice, but that's not super straightforward to do.
    set_user = function(..., user = list(...), unused_user_action = NULL) {
      private$odin$support_check_user(user, private$user, unused_user_action)
      .Call("scaling_cities_set_user", private$ptr, user, PACKAGE = "malthus")
      private$update_metadata()
    },

    ## This might be time sensitive and, so we can avoid computing
    ## it. I wonder if that's an optimisation we should drop for now
    ## as it does not seem generally useful. This would bring us
    ## closer to the js version which requires that we always pass the
    ## time in.
    initial = function(t) {
      .Call("scaling_cities_initial_conditions", private$ptr, t, PACKAGE = "malthus")
    },

    rhs = function(t, y) {
      .Call("scaling_cities_rhs_r", private$ptr, t, y, PACKAGE = "malthus")
    },

    deriv = function(t, y) {
      self$rhs(t, y)
    },

    contents = function() {
      .Call("scaling_cities_contents", private$ptr, PACKAGE = "malthus")
    },

    transform_variables = function(y) {
      private$odin$support_transform_variables(y, private)
    },

    engine = function() {
      "c"
    },

    run = function(t, y = NULL, ..., use_names = TRUE) {
      private$odin$wrapper_run_ode(
        self, private, t, y, ..., use_names = use_names)
    }
  ))


scaling_cities <- function(..., user = list(...), use_dde = FALSE,
                     unused_user_action = NULL) {
  asNamespace("odin")$deprecated_constructor_call("scaling_cities")
  scaling_cities_$new(user = user, use_dde = use_dde,
                unused_user_action = unused_user_action)
}
class(scaling_cities) <- "odin_generator"
attr(scaling_cities, "generator") <- scaling_cities_
stateless_war_ <- R6::R6Class(
  "odin_model",
  cloneable = FALSE,

  private = list(
    ptr = NULL,
    use_dde = NULL,

    odin = NULL,
    variable_order = NULL,
    output_order = NULL,
    n_out = NULL,
    ynames = NULL,
    interpolate_t = NULL,
    cfuns = list(
      rhs_dde = "stateless_war_rhs_dde",
      rhs_desolve = "stateless_war_rhs_desolve",
      initmod_desolve = "stateless_war_initmod_desolve"),
    dll = "malthus",
    user = c("a", "b", "K", "r"),

    ## This is never called, but is used to ensure that R finds our
    ## symbols that we will use from the package; without this they
    ## cannot be found by dynamic lookup now that we use the package
    ## FFI registration system.
    registration = function() {
      if (FALSE) {
        .C("stateless_war_rhs_dde", package = "malthus")
        .C("stateless_war_rhs_desolve", package = "malthus")
        .C("stateless_war_initmod_desolve", package = "malthus")
      }
    },

    ## This only does something in delay models
    set_initial = function(t, y, use_dde) {
      .Call("stateless_war_set_initial", private$ptr, t, y, use_dde,
            PACKAGE= "malthus")
    },

    update_metadata = function() {
      meta <- .Call("stateless_war_metadata", private$ptr,
                    PACKAGE = "malthus")
      private$variable_order <- meta$variable_order
      private$output_order <- meta$output_order
      private$n_out <- meta$n_out
      private$ynames <- private$odin$make_names(
        private$variable_order, private$output_order, FALSE)
      private$interpolate_t <- meta$interpolate_t
    }
  ),

  public = list(
    initialize = function(..., user = list(...), use_dde = FALSE,
                          unused_user_action = NULL) {
      private$odin <- asNamespace("odin")
      private$ptr <- .Call("stateless_war_create", user, PACKAGE = "malthus")
      self$set_user(user = user, unused_user_action = unused_user_action)
      private$use_dde <- use_dde
      private$update_metadata()
    },

    ir = function() {
      path_ir <- system.file("odin/stateless_war.json", mustWork = TRUE,
                             package = "malthus")
      json <- readLines(path_ir)
      class(json) <- "json"
      json
    },

    ## Do we need to have the user-settable args here? It would be
    ## nice, but that's not super straightforward to do.
    set_user = function(..., user = list(...), unused_user_action = NULL) {
      private$odin$support_check_user(user, private$user, unused_user_action)
      .Call("stateless_war_set_user", private$ptr, user, PACKAGE = "malthus")
      private$update_metadata()
    },

    ## This might be time sensitive and, so we can avoid computing
    ## it. I wonder if that's an optimisation we should drop for now
    ## as it does not seem generally useful. This would bring us
    ## closer to the js version which requires that we always pass the
    ## time in.
    initial = function(t) {
      .Call("stateless_war_initial_conditions", private$ptr, t, PACKAGE = "malthus")
    },

    rhs = function(t, y) {
      .Call("stateless_war_rhs_r", private$ptr, t, y, PACKAGE = "malthus")
    },

    deriv = function(t, y) {
      self$rhs(t, y)
    },

    contents = function() {
      .Call("stateless_war_contents", private$ptr, PACKAGE = "malthus")
    },

    transform_variables = function(y) {
      private$odin$support_transform_variables(y, private)
    },

    engine = function() {
      "c"
    },

    run = function(t, y = NULL, ..., use_names = TRUE) {
      private$odin$wrapper_run_ode(
        self, private, t, y, ..., use_names = use_names)
    }
  ))


stateless_war <- function(..., user = list(...), use_dde = FALSE,
                     unused_user_action = NULL) {
  asNamespace("odin")$deprecated_constructor_call("stateless_war")
  stateless_war_$new(user = user, use_dde = use_dde,
                unused_user_action = unused_user_action)
}
class(stateless_war) <- "odin_generator"
attr(stateless_war, "generator") <- stateless_war_
